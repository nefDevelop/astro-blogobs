---
import MessageBox from "@/components/common/PioMessageBox.astro";
import { spineModelConfig } from "@/config/pioConfig";
import { url } from "@/utils/url-utils";
---

<!-- El CSS de Spine Web Player se cargar√° din√°micamente en el script -->{
  spineModelConfig.enable && (
    <div
      id="spine-model-container"
      style={`
      position: fixed;
      ${spineModelConfig.position.corner.includes("right") ? "right" : "left"}: ${spineModelConfig.position.offsetX}px;
      ${spineModelConfig.position.corner.includes("top") ? "top" : "bottom"}: ${spineModelConfig.position.offsetY}px;
      width: ${spineModelConfig.size.width}px;
      height: ${spineModelConfig.size.height}px;
      pointer-events: auto;
      z-index: 1000;
    `}
    >
      <div id="spine-player-container" style="width: 100%; height: 100%;" />
      <div id="spine-error" style="display: none;" />
    </div>
  )
}

<!-- Importar el componente de cuadro de mensaje -->
<MessageBox />

<script is:inline define:vars={{ spineModelConfig, modelPath: url(spineModelConfig.model.path), atlasPath: url(spineModelConfig.model.path.replace(".json", ".atlas")), cssPath: url("/pio/static/spine-player.min.css"), jsPath: url("/pio/static/spine-player.min.js") }}>
  // Cargar din√°micamente el CSS de Spine (con respaldo local)
  function loadSpineCSS() {
    if (!spineModelConfig.enable) return;

    // Comprobar si ya est√° cargado
    const existingLink = document.querySelector('link[href*="spine-player"]');
    if (existingLink) return;

    // Intentar cargar primero el CSS del CDN
    const cdnLink = document.createElement("link");
    cdnLink.rel = "stylesheet";
    cdnLink.href =
      "https://unpkg.com/@esotericsoftware/spine-player@4.2.*/dist/spine-player.min.css";

    // Escuchar el evento de fallo de carga, retroceder autom√°ticamente al archivo local
    cdnLink.onerror = function () {
      console.warn("‚ö†Ô∏è Fall√≥ el CDN de CSS de Spine, intentando respaldo local...");

      // Eliminar el enlace del CDN fallido
      if (cdnLink.parentNode) {
        cdnLink.parentNode.removeChild(cdnLink);
      }

      // Crear enlace CSS de respaldo local
      const localLink = document.createElement("link");
      localLink.rel = "stylesheet";
      localLink.href = cssPath;
      localLink.onerror = function () {
        console.error("‚ùå Fall√≥ la carga del CSS de Spine");
      };

      document.head.appendChild(localLink);
    };

    document.head.appendChild(cdnLink);
  }

  // La funcionalidad del cuadro de mensaje se ha movido al componente p√∫blico MessageBox.astro
  let isClickProcessing = false; // Bandera para prevenir clics repetidos
  let lastClickTime = 0; // Registrar la hora del √∫ltimo clic

  // Variables globales para prevenir la reinicializaci√≥n
  window.spineModelInitialized = window.spineModelInitialized || false;
  window.spinePlayerInstance = window.spinePlayerInstance || null;

  // Funci√≥n de visualizaci√≥n de mensajes - usa el componente de cuadro de mensaje p√∫blico
  function showMessage(message) {
    // Usar el componente de cuadro de mensaje p√∫blico
    if (window.showModelMessage) {
      window.showModelMessage(message, {
        containerId: "spine-model-container",
        displayTime: spineModelConfig.interactive.messageDisplayTime || 3000
      });
    }
  }

  // Actualizar la visualizaci√≥n responsiva
  function updateResponsiveDisplay() {
    if (!spineModelConfig.enable) return;

    const container = document.getElementById("spine-model-container");
    if (!container) return;

    // Comprobar la configuraci√≥n de visualizaci√≥n en m√≥viles
    if (
      spineModelConfig.responsive.hideOnMobile &&
      window.innerWidth <= spineModelConfig.responsive.mobileBreakpoint
    ) {
      container.style.display = "none";
    } else {
      container.style.display = "block";
    }
  }

  // Funci√≥n de limpieza
  function cleanupSpineModel() {
    console.log("üßπ Limpiando el modelo de Spine existente...");

    // Limpiar la visualizaci√≥n de mensajes (usando el componente p√∫blico)
    if (window.clearModelMessage) {
      window.clearModelMessage();
    }

    // Limpiar la instancia del reproductor existente
    if (window.spinePlayerInstance) {
      try {
        if (window.spinePlayerInstance.dispose) {
          window.spinePlayerInstance.dispose();
        }
      } catch (e) {
        console.warn("Error disposing spine player:", e);
      }
      window.spinePlayerInstance = null;
    }

    // Limpiar el contenido del contenedor
    const playerContainer = document.getElementById("spine-player-container");
    if (playerContainer) {
      playerContainer.innerHTML = "";
    }

    // Restablecer la bandera de inicializaci√≥n
    window.spineModelInitialized = false;
  }

  async function initSpineModel() {
    if (!spineModelConfig.enable) return;

    // Comprobar la configuraci√≥n de visualizaci√≥n en m√≥viles, si est√° oculto no cargar el runtime
    if (
      spineModelConfig.responsive.hideOnMobile &&
      window.innerWidth <= spineModelConfig.responsive.mobileBreakpoint
    ) {
      console.log("üì± Dispositivo m√≥vil detectado, omitiendo la inicializaci√≥n del modelo de Spine");
      const container = document.getElementById("spine-model-container");
      if (container) container.style.display = "none";
      return;
    }

    // Comprobar si ya est√° inicializado
    if (window.spineModelInitialized) {
      console.log("‚è≠Ô∏è El modelo de Spine ya est√° inicializado, omitiendo...");
      return;
    }

    console.log("üéØ Inicializando el modelo de Spine...");

    // Limpiar primero las instancias antiguas que puedan existir
    cleanupSpineModel();

    // Cargar primero el CSS
    loadSpineCSS();

    // Cargar el runtime de Spine Web Player
    const loadSpineRuntime = () => {
      return new Promise((resolve, reject) => {
        if (typeof window.spine !== "undefined") {
          console.log("‚úÖ El runtime de Spine ya est√° cargado");
          resolve();
          return;
        }

        console.log("üì¶ Cargando el runtime de Spine...");
        const script = document.createElement("script");
        script.src =
          "https://unpkg.com/@esotericsoftware/spine-player@4.2.*/dist/iife/spine-player.min.js";
        script.onload = () => {
          console.log("‚úÖ Runtime de Spine cargado desde el CDN");
          resolve();
        };
        script.onerror = (_error) => {
          console.warn("‚ö†Ô∏è Fall√≥ el CDN, intentando respaldo local...");

          // Intentar respaldo local
          const fallbackScript = document.createElement("script");
          fallbackScript.src = jsPath;
          fallbackScript.onload = () => {
            console.log("‚úÖ Runtime de Spine cargado desde el respaldo local");
            resolve();
          };
          fallbackScript.onerror = () => {
            reject(new Error("Fall√≥ la carga del runtime de Spine"));
          };
          document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(script);
      });
    };

    // Esperar a que la librer√≠a de Spine cargue
    const waitForSpine = () => {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 50;

        const check = () => {
          attempts++;
          if (typeof window.spine !== "undefined" && window.spine.SpinePlayer) {
            console.log("‚úÖ El runtime de Spine est√° cargado");
            resolve();
          } else if (attempts >= maxAttempts) {
            reject(new Error("Tiempo de espera de carga del runtime de Spine agotado"));
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    };

    try {
      // Cargar primero el runtime de Spine
      await loadSpineRuntime();

      // Luego esperar a que el objeto Spine est√© disponible
      await waitForSpine();

      // Marcar como inicializado
      window.spineModelInitialized = true;

      // Crear SpinePlayer
      new window.spine.SpinePlayer("spine-player-container", {
        skeleton: modelPath,
        atlas: atlasPath,
        animation: "idle",
        backgroundColor: "#00000000", // Fondo transparente
        showControls: false, // Ocultar controles
        alpha: true,
        premultipliedAlpha: false,
        success: (player) => {
          console.log("üéâ ¬°Modelo de Spine cargado con √©xito!");

          // Guardar la referencia de la instancia del reproductor
          window.spinePlayerInstance = player;

          // Establecer la pose por defecto despu√©s de la inicializaci√≥n
          setTimeout(() => {
            if (player.skeleton) {
              try {
                player.skeleton.updateWorldTransform();
                player.skeleton.setToSetupPose();
              } catch (e) {
                console.warn("Error positioning skeleton:", e);
              }
            }
          }, 500);

          // Configurar la funcionalidad interactiva
          if (spineModelConfig.interactive.enabled) {
            const canvas = document.querySelector(
              "#spine-player-container canvas"
            );
            if (canvas) {
              canvas.addEventListener("click", () => {
                // Manejo de debounce: prevenir clics repetidos
                const currentTime = Date.now();
                if (isClickProcessing || currentTime - lastClickTime < 500) {
                  return; // Ignorar clics repetidos dentro de 500ms
                }

                isClickProcessing = true;
                lastClickTime = currentTime;

                // Reproducir animaci√≥n de clic aleatoria
                const clickAnims =
                  spineModelConfig.interactive.clickAnimations ||
                  (spineModelConfig.interactive.clickAnimation
                    ? [spineModelConfig.interactive.clickAnimation]
                    : []);

                if (clickAnims.length > 0) {
                  try {
                    const randomClickAnim =
                      clickAnims[Math.floor(Math.random() * clickAnims.length)];
                    player.setAnimation(randomClickAnim, false);

                    // Volver al estado de reposo despu√©s de que termine la animaci√≥n
                    setTimeout(() => {
                      const idleAnims =
                        spineModelConfig.interactive.idleAnimations;
                      const randomIdle =
                        idleAnims[Math.floor(Math.random() * idleAnims.length)];
                      player.setAnimation(randomIdle, true);
                    }, 2000);
                  } catch (e) {
                    console.warn("Failed to play click animation:", e);
                  }
                }

                // Mostrar mensaje aleatorio
                const messages = spineModelConfig.interactive.clickMessages;
                if (messages && messages.length > 0) {
                  const randomMessage =
                    messages[Math.floor(Math.random() * messages.length)];
                  showMessage(randomMessage);
                }

                // Restablecer la bandera de debounce despu√©s de 500ms
                setTimeout(() => {
                  isClickProcessing = false;
                }, 500);
              });

              // Configurar el bucle de la animaci√≥n de reposo
              if (spineModelConfig.interactive.idleAnimations.length > 1) {
                setInterval(() => {
                  try {
                    const idleAnims =
                      spineModelConfig.interactive.idleAnimations;
                    const randomIdle =
                      idleAnims[Math.floor(Math.random() * idleAnims.length)];
                    player.setAnimation(randomIdle, true);
                  } catch (e) {
                    console.warn("Failed to play idle animation:", e);
                  }
                }, spineModelConfig.interactive.idleInterval);
              }
            }
          }

          console.log("‚úÖ Spine model setup complete!");
        },
        error: (_player, reason) => {
          console.error("‚ùå Error al cargar el modelo de Spine:", reason);

          const errorDiv = document.getElementById("spine-error");
          if (errorDiv) {
            errorDiv.style.display = "block";
            errorDiv.innerHTML = `
              <div style="color: #ff4444; padding: 20px; text-align: center; font-size: 14px;">
                <div>‚ö†Ô∏è Fallo al cargar el modelo Spine</div>
                <div style="font-size: 12px; margin-top: 8px; color: #888;">${reason}</div>
              </div>
            `;
          }

          const canvas = document.getElementById("spine-canvas");
          if (canvas) canvas.style.display = "none";
        },
      });
    } catch (error) {
      console.error("Error de inicializaci√≥n del modelo de Spine:", error);

      // Restablecer la bandera de inicializaci√≥n, permitir reintentos
      window.spineModelInitialized = false;

      const errorDiv = document.getElementById("spine-error");
      if (errorDiv) {
        errorDiv.style.display = "block";
        errorDiv.innerHTML = `
          <div style="color: #ff4444; padding: 20px; text-align: center; font-size: 14px;">
                <div>‚ö†Ô∏è Fallo al cargar el runtime de Spine</div>
                <div style="font-size: 12px; margin-top: 8px; color: #888;">${error instanceof Error ? error.message : "Error desconocido"}</div>
              </div>
        `;
      }
    }
  }

  // Escuchar el evento beforeunload de la p√°gina para limpiar recursos
  window.addEventListener("beforeunload", cleanupSpineModel);

  // Escuchar el evento de cambio de p√°gina de Swup (si se usa Swup)
  if (typeof window.swup !== "undefined" && window.swup.hooks) {
    window.swup.hooks.on("content:replace", () => {
      // Solo actualizar la visualizaci√≥n responsiva, no recrear el modelo
      setTimeout(() => {
        updateResponsiveDisplay();
      }, 100);
    });
  }

  // Escuchar el evento popstate (navegaci√≥n adelante/atr√°s del navegador)
  window.addEventListener("popstate", () => {
    setTimeout(() => {
      updateResponsiveDisplay();
    }, 100);
  });

  // Escuchar los cambios de tama√±o de la ventana
  window.addEventListener("resize", updateResponsiveDisplay);

  // Inicializar despu√©s de que la p√°gina se cargue (solo una vez)
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSpineModel);
  } else {
    initSpineModel();
  }
</script>
